package org.catacombae.hfsexplorer.types.hfs;

import java.io.PrintStream;
import org.catacombae.csjc.DynamicStruct;
import org.catacombae.hfsexplorer.Util;

/** This class was generated by CStructToJavaClass. */
public class CatKeyRec implements DynamicStruct {
    /*
     * struct CatKeyRec
     * size: 38 bytes
     * description: 
     * 
     * BP  Size  Type      Identifier  Description                  
     * -------------------------------------------------------------
     * 0   1     SInt8     ckrKeyLen   key length (SignedByte)      
     * 1   1     SInt8     ckrResrv1   reserved (SignedByte)        
     * 2   4     SInt32    ckrParID    parent directory ID (LongInt)
     * 6   1*32  Char[32]  ckrCName    catalog node name (Str31)    
     */
    
    private static final int MAX_STRUCTSIZE = 38;
    
    private final byte[] ckrKeyLen = new byte[1];
    private final byte[] ckrResrv1 = new byte[1];
    private final byte[] ckrParID = new byte[4];
    private final byte[] ckrCName;// = new byte[1*32];

    public CatKeyRec(byte[] data, int offset) {
	System.arraycopy(data, offset+0, ckrKeyLen, 0, 1);
	System.arraycopy(data, offset+1, ckrResrv1, 0, 1);
	System.arraycopy(data, offset+2, ckrParID, 0, 4);
        
        int structSize = 2+Util.unsign(getCkrKeyLen());
        if(structSize >= 6 && structSize < MAX_STRUCTSIZE) {
            int cNameLen = structSize - 6;
            ckrCName = new byte[cNameLen];
            System.arraycopy(data, offset+6, ckrCName, 0, ckrCName.length);
        }
        else
            throw new RuntimeException("Incorrect value for ckrKeyLen: " +
                    Util.unsign(getCkrKeyLen()));
    }

    /**
     * Builds a CatKeyRec from a specified nodeID and a string.
     * @param parID
     * @param cName
     */
    public CatKeyRec(int parID, byte[] cName) {
        if(cName.length < 0 || cName.length > 32)
            throw new IllegalArgumentException("String too large for a catalog file key!");
        byte[] parIDBytes = Util.toByteArrayBE(parID);
        if(parIDBytes.length != 4)
            throw new RuntimeException("Internal error! int array not 4 bytes but " +
                    parIDBytes.length);
        this.ckrCName = new byte[cName.length];

        ckrKeyLen[0] = (byte)(1 + 4 + cName.length); // length of the rest of the key
        ckrResrv1[0] = 0; // Reserved
	System.arraycopy(parIDBytes, 0, ckrParID, 0, ckrParID.length);
        System.arraycopy(cName, 0, ckrCName, 0, ckrCName.length);
    }

    //public int length() { return occupiedSize(); }
    
    public byte getCkrKeyLen() { return Util.readByteBE(ckrKeyLen); }
    public byte getCkrResrv1() { return Util.readByteBE(ckrResrv1); }
    public int getCkrParID() { return Util.readIntBE(ckrParID); }
    public byte[] getCkrCName() { return Util.createCopy(ckrCName); }
    
    public void printFields(PrintStream ps, String prefix) {
	ps.println(prefix + " ckrKeyLen: " + getCkrKeyLen());
	ps.println(prefix + " ckrResrv1: " + getCkrResrv1());
	ps.println(prefix + " ckrParID: " + getCkrParID());
	ps.println(prefix + " ckrCName: " + getCkrCName());
    }
    
    public void print(PrintStream ps, String prefix) {
	ps.println(prefix + "CatKeyRec:");
	printFields(ps, prefix);
    }
    
    public byte[] getBytes() {
	byte[] result = new byte[occupiedSize()];
	int offset = 0;
        
        System.arraycopy(ckrKeyLen, 0, result, offset, ckrKeyLen.length); offset += ckrKeyLen.length;
	System.arraycopy(ckrResrv1, 0, result, offset, ckrResrv1.length); offset += ckrResrv1.length;
	System.arraycopy(ckrParID, 0, result, offset, ckrParID.length); offset += ckrParID.length;
	System.arraycopy(ckrCName, 0, result, offset, ckrCName.length); offset += ckrCName.length;
	return result;
    }

    public int maxSize() {
        return MAX_STRUCTSIZE;
    }

    public int occupiedSize() {
        return 2+Util.unsign(getCkrKeyLen());
    }
}
