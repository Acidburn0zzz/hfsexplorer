/*-
 * Copyright (C) 2006-2007 Erik Larsson
 * 
 * All rights reserved.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

package org.catacombae.hfsexplorer.partitioning;

import org.catacombae.hfsexplorer.Util;
import java.io.PrintStream;
import java.nio.LongBuffer;
import java.util.Hashtable;

/** This class was generated by CStructToJavaClass. */
public class GPTEntry extends Partition {
    /*
     * Microsoft info:
     *
     * Unused entry                              {00000000-0000-0000-0000-000000000000}
     * EFI System partition                      {28732AC1-1FF8-D211-BA4B-00A0C93EC93B}
     * Microsoft Reserved partition              {16E3C9E3-5C0B-B84D-817D-F92DF00215AE}
     * Primary partition on a basic disk         {A2A0D0EB-E5B9-3344-87C0-68B6B72699C7}
     * LDM Metadata partition on a dynamic disk  {AAC80858-8F7E-E042-85D2-E1E90434CFB3}
     * LDM Data partition on a dynamic disk      {A0609BAF-3114-624F-BC68-3311714A69AD}
     *
     * Wikipedia info:
     *   HFS+ (Wikipedia)                        {48465300-0000-11AA-AA11-00306543ECAC}
     *   HFS+ (My own observation)               {00534648-0000-AA11-AA11-00306543ECAC}
     */
    private static final Hashtable<LongBuffer,GPTPartitionType> byteMap = new Hashtable<LongBuffer,GPTPartitionType>();
    public static enum GPTPartitionType {
	PARTITION_TYPE_UNUSED_ENTRY             ((long)0x0000000000000000L, (long)0x0000000000000000L),
	    PARTITION_TYPE_EFI_SYSTEM           ((long)0x28732AC11FF8D211L, (long)0xBA4B00A0C93EC93BL),
	    PARTITION_TYPE_MICROSOFT_RESERVED   ((long)0x16E3C9E35C0BB84DL, (long)0x817DF92DF00215AEL),
	    PARTITION_TYPE_PRIMARY_PARTITION    ((long)0xA2A0D0EBE5B93344L, (long)0x87C068B6B72699C7L),
	    PARTITION_TYPE_LDM_METADATA         ((long)0xAAC808588F7EE042L, (long)0x85D2E1E90434CFB3L),
	    PARTITION_TYPE_LDM_DATA             ((long)0xA0609BAF3114624FL, (long)0xBC683311714A69ADL),
// 	    PARTITION_TYPE_APPLE_HFS            ((long)0x48465300000011AAL, (long)0xAA1100306543ECACL), //Wikipedia
	    PARTITION_TYPE_APPLE_HFS            ((long)0x005346480000AA11L, (long)0xAA1100306543ECACL), //My disc..
	    UNKNOWN_PARTITION_TYPE; // Returned when no known type can be matched
	
	private long typeGUIDMsb;
	private long typeGUIDLsb;
	
	private GPTPartitionType(long typeGUIDMsb, long typeGUIDLsb) {
	    this.typeGUIDMsb = typeGUIDMsb;
	    this.typeGUIDLsb = typeGUIDLsb;
	    byteMap.put(LongBuffer.wrap(new long[] { typeGUIDMsb, typeGUIDLsb }), this);
	}
	private GPTPartitionType() {}
		
	public static GPTPartitionType getType(long typeGUIDMsb, long typeGUIDLsb) {
	    GPTPartitionType type = byteMap.get(LongBuffer.wrap(new long[] { typeGUIDMsb, typeGUIDLsb }));
	    if(type != null)
		return type;
	    else
		return UNKNOWN_PARTITION_TYPE;
	}
    }
    
    /*
     * struct GPTEntry
     * size: 128 bytes
     * description: 
     * 
     * BP  Size  Type      Identifier           Description
     * ----------------------------------------------------
     * 0   16    byte[16]  partitionTypeGUID               
     * 16  16    byte[16]  uniquePartitionGUID             
     * 32  8     UInt64    startingLBA                     
     * 40  8     UInt64    endingLBA                       
     * 48  8     UInt64    attributeBits                   
     * 56  72    byte[72]  partitionName                   
     */
    
    private final byte[] partitionTypeGUID = new byte[16];
    private final byte[] uniquePartitionGUID = new byte[16];
    private final byte[] startingLBA = new byte[8];
    private final byte[] endingLBA = new byte[8];
    private final byte[] attributeBits = new byte[8];
    private final byte[] partitionName = new byte[72];
    
    public GPTEntry(byte[] data, int offset, int blockSize) {
	System.arraycopy(data, offset+0, partitionTypeGUID, 0, 16);
	System.arraycopy(data, offset+16, uniquePartitionGUID, 0, 16);
	System.arraycopy(data, offset+32, startingLBA, 0, 8);
	System.arraycopy(data, offset+40, endingLBA, 0, 8);
	System.arraycopy(data, offset+48, attributeBits, 0, 8);
	System.arraycopy(data, offset+56, partitionName, 0, 72);
	
	// Added to make it work as subclass of Partition
	startOffset = getStartingLBA()*blockSize;
	length = getEndingLBA()*blockSize - startOffset;
	type = convertPartitionType(getPartitionTypeGUIDAsEnum());
    }
    
    public static int length() { return 128; }
    
    public byte[] getPartitionTypeGUID() { return Util.createCopy(partitionTypeGUID); }
    public byte[] getUniquePartitionGUID() { return Util.createCopy(uniquePartitionGUID); }
    public long getStartingLBA() { return Util.readLongBE(startingLBA); }
    public long getEndingLBA() { return Util.readLongBE(endingLBA); }
    public long getAttributeBits() { return Util.readLongBE(attributeBits); }
    public byte[] getPartitionName() { return Util.createCopy(partitionName); }
    
    public static String getGUIDAsString(byte[] guid) {
	String res = "{";
	res += Util.byteArrayToHexString(guid, 0, 4) + "-";
	res += Util.byteArrayToHexString(guid, 4, 2) + "-";
	res += Util.byteArrayToHexString(guid, 6, 2) + "-";
	res += Util.byteArrayToHexString(guid, 8, 2) + "-";
	res += Util.byteArrayToHexString(guid, 10, 6) + "}";
	return res;
    }
    public GPTPartitionType getPartitionTypeGUIDAsEnum() {
	return GPTPartitionType.getType(Util.readLongBE(partitionTypeGUID, 0), Util.readLongBE(partitionTypeGUID, 8));
    }
    
    public void printFields(PrintStream ps, String prefix) {
	ps.println(prefix + " partitionTypeGUID: " + getGUIDAsString(getPartitionTypeGUID()));
	ps.println(prefix + " uniquePartitionGUID: " + getGUIDAsString(getUniquePartitionGUID()));
	ps.println(prefix + " startingLBA: " + getStartingLBA());
	ps.println(prefix + " endingLBA: " + getEndingLBA());
	ps.println(prefix + " attributeBits: " + getAttributeBits());
	ps.println(prefix + " partitionName: " + Util.toASCIIString(getPartitionName()));
    }
    
    public void print(PrintStream ps, String prefix) {
	ps.println(prefix + "GPTEntry:");
	printFields(ps, prefix);
    }
    
    public static PartitionType convertPartitionType(GPTPartitionType gpt) {
	switch(gpt) {
	case PARTITION_TYPE_APPLE_HFS:
	    return PartitionType.APPLE_HFS;
	case PARTITION_TYPE_PRIMARY_PARTITION:
	    return PartitionType.NTFS;
	default:
	    return PartitionType.UNKNOWN;
	}
    }
}
